package devflow

import (
	"strings"
	"testing"
)

func TestNewCommitMessage(t *testing.T) {
	msg := NewCommitMessage(CommitTypeFeat, "add user authentication")

	if msg.Type != CommitTypeFeat {
		t.Errorf("Type = %q, want %q", msg.Type, CommitTypeFeat)
	}
	if msg.Subject != "add user authentication" {
		t.Errorf("Subject = %q, want %q", msg.Subject, "add user authentication")
	}
	if msg.GeneratedBy != "devflow" {
		t.Errorf("GeneratedBy = %q, want %q", msg.GeneratedBy, "devflow")
	}
}

func TestCommitMessage_String(t *testing.T) {
	t.Run("simple message", func(t *testing.T) {
		msg := NewCommitMessage(CommitTypeFeat, "add user authentication")
		got := msg.String()

		if !strings.HasPrefix(got, "feat: add user authentication") {
			t.Errorf("should start with type and subject, got:\n%s", got)
		}
		if !strings.Contains(got, "Generated-By: devflow") {
			t.Errorf("should contain Generated-By footer, got:\n%s", got)
		}
	})

	t.Run("with scope", func(t *testing.T) {
		msg := NewCommitMessage(CommitTypeFeat, "add OAuth support").
			WithScope("auth")
		got := msg.String()

		if !strings.HasPrefix(got, "feat(auth): add OAuth support") {
			t.Errorf("should include scope, got:\n%s", got)
		}
	})

	t.Run("with body", func(t *testing.T) {
		msg := NewCommitMessage(CommitTypeFix, "handle null response").
			WithBody("The API was returning null for empty arrays.")
		got := msg.String()

		if !strings.Contains(got, "\n\nThe API was returning null") {
			t.Errorf("should have body separated by blank line, got:\n%s", got)
		}
	})

	t.Run("with ticket refs", func(t *testing.T) {
		msg := NewCommitMessage(CommitTypeFeat, "add feature").
			WithTicketRef("TK-421").
			WithTicketRef("TK-422")
		got := msg.String()

		if !strings.Contains(got, "Refs: TK-421") {
			t.Errorf("should contain first ticket ref, got:\n%s", got)
		}
		if !strings.Contains(got, "Refs: TK-422") {
			t.Errorf("should contain second ticket ref, got:\n%s", got)
		}
	})

	t.Run("with co-author", func(t *testing.T) {
		msg := NewCommitMessage(CommitTypeFeat, "add feature").
			WithCoAuthor("alice@example.com")
		got := msg.String()

		if !strings.Contains(got, "Co-authored-by: alice@example.com") {
			t.Errorf("should contain co-author, got:\n%s", got)
		}
	})

	t.Run("breaking change", func(t *testing.T) {
		msg := NewCommitMessage(CommitTypeFeat, "change API response format").
			WithBreaking()
		got := msg.String()

		if !strings.HasPrefix(got, "feat!: change API response format") {
			t.Errorf("should have ! for breaking change, got:\n%s", got)
		}
	})

	t.Run("without generated by", func(t *testing.T) {
		msg := NewCommitMessage(CommitTypeFeat, "manual change").
			WithoutGeneratedBy()
		got := msg.String()

		if strings.Contains(got, "Generated-By") {
			t.Errorf("should not contain Generated-By, got:\n%s", got)
		}
	})

	t.Run("full message", func(t *testing.T) {
		msg := NewCommitMessage(CommitTypeFix, "handle null response in API").
			WithScope("api").
			WithBody("The API was returning null for empty arrays, causing client crashes. This normalizes empty arrays to [] in the response serializer.").
			WithTicketRef("TK-422")

		got := msg.String()

		// Check structure
		lines := strings.Split(got, "\n")

		// First line should be subject
		if lines[0] != "fix(api): handle null response in API" {
			t.Errorf("first line = %q, want subject line", lines[0])
		}

		// Second line should be empty
		if lines[1] != "" {
			t.Errorf("second line should be empty for body separator")
		}

		// Should contain body (wrapped)
		if !strings.Contains(got, "The API was returning null") {
			t.Errorf("should contain body text")
		}

		// Footer
		if !strings.Contains(got, "Refs: TK-422") {
			t.Errorf("should contain ticket ref")
		}
		if !strings.Contains(got, "Generated-By: devflow") {
			t.Errorf("should contain Generated-By")
		}
	})
}

func TestCommitMessage_Validate(t *testing.T) {
	t.Run("valid message", func(t *testing.T) {
		msg := NewCommitMessage(CommitTypeFeat, "add feature")
		if err := msg.Validate(); err != nil {
			t.Errorf("Validate() = %v, want nil", err)
		}
	})

	t.Run("missing type", func(t *testing.T) {
		msg := &CommitMessage{Subject: "test"}
		if err := msg.Validate(); err == nil {
			t.Error("Validate() should return error for missing type")
		}
	})

	t.Run("missing subject", func(t *testing.T) {
		msg := &CommitMessage{Type: CommitTypeFeat}
		if err := msg.Validate(); err == nil {
			t.Error("Validate() should return error for missing subject")
		}
	})

	t.Run("subject too long", func(t *testing.T) {
		msg := NewCommitMessage(CommitTypeFeat, strings.Repeat("a", 101))
		if err := msg.Validate(); err == nil {
			t.Error("Validate() should return error for long subject")
		}
	})
}

func TestCommitTypes(t *testing.T) {
	types := []CommitType{
		CommitTypeFeat,
		CommitTypeFix,
		CommitTypeDocs,
		CommitTypeStyle,
		CommitTypeRefactor,
		CommitTypePerf,
		CommitTypeTest,
		CommitTypeBuild,
		CommitTypeCI,
		CommitTypeChore,
		CommitTypeRevert,
	}

	for _, typ := range types {
		t.Run(string(typ), func(t *testing.T) {
			msg := NewCommitMessage(typ, "test message")
			got := msg.String()
			if !strings.HasPrefix(got, string(typ)+": ") && !strings.HasPrefix(got, string(typ)+"(") {
				t.Errorf("message should start with type %q, got:\n%s", typ, got)
			}
		})
	}
}

func TestWrapText(t *testing.T) {
	tests := []struct {
		name  string
		input string
		width int
		check func(string) bool
	}{
		{
			name:  "short text unchanged",
			input: "Short text",
			width: 72,
			check: func(s string) bool { return s == "Short text" },
		},
		{
			name:  "long line wrapped",
			input: "This is a very long line that should definitely be wrapped because it exceeds the specified width limit",
			width: 40,
			check: func(s string) bool {
				for _, line := range strings.Split(s, "\n") {
					if len(line) > 45 { // Allow some slack for word boundaries
						return false
					}
				}
				return true
			},
		},
		{
			name:  "preserves newlines",
			input: "First paragraph.\n\nSecond paragraph.",
			width: 72,
			check: func(s string) bool {
				return strings.Contains(s, "\n\n")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := wrapText(tt.input, tt.width)
			if !tt.check(got) {
				t.Errorf("wrapText(%q, %d) = %q", tt.input, tt.width, got)
			}
		})
	}
}

func TestDefaultCommitConfig(t *testing.T) {
	cfg := DefaultCommitConfig()

	if !cfg.IncludeGeneratedBy {
		t.Error("IncludeGeneratedBy should be true by default")
	}
	if cfg.TicketRefPrefix != "Refs:" {
		t.Errorf("TicketRefPrefix = %q, want %q", cfg.TicketRefPrefix, "Refs:")
	}
	if cfg.RequireTicketRef {
		t.Error("RequireTicketRef should be false by default")
	}
}
