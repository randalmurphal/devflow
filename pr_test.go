package devflow

import (
	"strings"
	"testing"
)

func TestNewPRBuilder(t *testing.T) {
	builder := NewPRBuilder("Add user authentication")
	opts := builder.Build()

	if opts.Title != "Add user authentication" {
		t.Errorf("Title = %q, want %q", opts.Title, "Add user authentication")
	}
	if opts.Base != "main" {
		t.Errorf("Base = %q, want %q", opts.Base, "main")
	}
}

func TestPRBuilder_WithTicket(t *testing.T) {
	opts := NewPRBuilder("Add user authentication").
		WithTicket("TK-421").
		Build()

	if opts.Title != "[TK-421] Add user authentication" {
		t.Errorf("Title = %q, want %q", opts.Title, "[TK-421] Add user authentication")
	}
}

func TestPRBuilder_WithBody(t *testing.T) {
	body := "This PR implements user authentication using OAuth2."
	opts := NewPRBuilder("Add auth").
		WithBody(body).
		Build()

	if opts.Body != body {
		t.Errorf("Body = %q, want %q", opts.Body, body)
	}
}

func TestPRBuilder_WithSummary(t *testing.T) {
	opts := NewPRBuilder("Add auth").
		WithSummary(
			"Implements OAuth2 login flow",
			[]string{"Add OAuth handler", "Add session management"},
			"Click login button and verify flow",
		).
		Build()

	if !strings.Contains(opts.Body, "## Summary") {
		t.Error("Body should contain Summary section")
	}
	if !strings.Contains(opts.Body, "Implements OAuth2 login flow") {
		t.Error("Body should contain summary text")
	}
	if !strings.Contains(opts.Body, "## Changes") {
		t.Error("Body should contain Changes section")
	}
	if !strings.Contains(opts.Body, "- Add OAuth handler") {
		t.Error("Body should contain change items")
	}
	if !strings.Contains(opts.Body, "## Test Plan") {
		t.Error("Body should contain Test Plan section")
	}
	if !strings.Contains(opts.Body, "*Generated by devflow*") {
		t.Error("Body should contain devflow marker")
	}
}

func TestPRBuilder_WithBase(t *testing.T) {
	opts := NewPRBuilder("Feature").
		WithBase("develop").
		Build()

	if opts.Base != "develop" {
		t.Errorf("Base = %q, want %q", opts.Base, "develop")
	}
}

func TestPRBuilder_WithHead(t *testing.T) {
	opts := NewPRBuilder("Feature").
		WithHead("feature/my-branch").
		Build()

	if opts.Head != "feature/my-branch" {
		t.Errorf("Head = %q, want %q", opts.Head, "feature/my-branch")
	}
}

func TestPRBuilder_WithLabels(t *testing.T) {
	opts := NewPRBuilder("Feature").
		WithLabels("feature", "auth").
		WithLabels("priority-high").
		Build()

	if len(opts.Labels) != 3 {
		t.Errorf("len(Labels) = %d, want 3", len(opts.Labels))
	}
	if opts.Labels[0] != "feature" {
		t.Errorf("Labels[0] = %q, want %q", opts.Labels[0], "feature")
	}
}

func TestPRBuilder_WithReviewers(t *testing.T) {
	opts := NewPRBuilder("Feature").
		WithReviewers("alice", "bob").
		Build()

	if len(opts.Reviewers) != 2 {
		t.Errorf("len(Reviewers) = %d, want 2", len(opts.Reviewers))
	}
}

func TestPRBuilder_WithAssignees(t *testing.T) {
	opts := NewPRBuilder("Feature").
		WithAssignees("charlie").
		Build()

	if len(opts.Assignees) != 1 {
		t.Errorf("len(Assignees) = %d, want 1", len(opts.Assignees))
	}
}

func TestPRBuilder_AsDraft(t *testing.T) {
	opts := NewPRBuilder("Feature").
		AsDraft().
		Build()

	if !opts.Draft {
		t.Error("Draft should be true")
	}
}

func TestPRBuilder_WithMilestone(t *testing.T) {
	opts := NewPRBuilder("Feature").
		WithMilestone("v1.0").
		Build()

	if opts.Milestone != "v1.0" {
		t.Errorf("Milestone = %q, want %q", opts.Milestone, "v1.0")
	}
}

func TestPRBuilder_WithMetadata(t *testing.T) {
	opts := NewPRBuilder("Feature").
		WithMetadata("workflow_id", "123").
		WithMetadata("run_id", "456").
		Build()

	if opts.Metadata["workflow_id"] != "123" {
		t.Errorf("Metadata[workflow_id] = %q, want %q", opts.Metadata["workflow_id"], "123")
	}
	if opts.Metadata["run_id"] != "456" {
		t.Errorf("Metadata[run_id] = %q, want %q", opts.Metadata["run_id"], "456")
	}
}

func TestPRBuilder_ChainedCalls(t *testing.T) {
	opts := NewPRBuilder("Add user authentication").
		WithTicket("TK-421").
		WithBody("Full description here").
		WithBase("main").
		WithHead("feature/tk-421").
		WithLabels("feature").
		WithReviewers("alice").
		WithAssignees("bob").
		AsDraft().
		WithMilestone("v1.0").
		Build()

	if opts.Title != "[TK-421] Add user authentication" {
		t.Errorf("unexpected Title: %q", opts.Title)
	}
	if opts.Body != "Full description here" {
		t.Errorf("unexpected Body: %q", opts.Body)
	}
	if opts.Base != "main" {
		t.Errorf("unexpected Base: %q", opts.Base)
	}
	if opts.Head != "feature/tk-421" {
		t.Errorf("unexpected Head: %q", opts.Head)
	}
	if len(opts.Labels) != 1 || opts.Labels[0] != "feature" {
		t.Errorf("unexpected Labels: %v", opts.Labels)
	}
	if !opts.Draft {
		t.Error("Draft should be true")
	}
}

func TestDetectProvider(t *testing.T) {
	tests := []struct {
		url     string
		want    string
		wantErr bool
	}{
		{"https://github.com/owner/repo.git", "github", false},
		{"git@github.com:owner/repo.git", "github", false},
		{"https://gitlab.com/owner/repo.git", "gitlab", false},
		{"https://gitlab.example.com/owner/repo.git", "gitlab", false},
		{"git@gitlab.example.com:owner/repo.git", "gitlab", false},
		{"https://bitbucket.org/owner/repo.git", "bitbucket", false},
		{"https://unknown.com/owner/repo.git", "", true},
	}

	for _, tt := range tests {
		t.Run(tt.url, func(t *testing.T) {
			got, err := DetectProvider(tt.url)
			if tt.wantErr {
				if err == nil {
					t.Errorf("DetectProvider(%q) should return error", tt.url)
				}
				return
			}
			if err != nil {
				t.Errorf("DetectProvider(%q) error = %v", tt.url, err)
				return
			}
			if got != tt.want {
				t.Errorf("DetectProvider(%q) = %q, want %q", tt.url, got, tt.want)
			}
		})
	}
}

func TestParseRepoFromURL(t *testing.T) {
	tests := []struct {
		url       string
		wantOwner string
		wantRepo  string
		wantErr   bool
	}{
		// HTTPS URLs
		{"https://github.com/rmurphy/devflow.git", "rmurphy", "devflow", false},
		{"https://github.com/rmurphy/devflow", "rmurphy", "devflow", false},
		{"https://gitlab.com/namespace/project.git", "namespace", "project", false},
		// SSH URLs
		{"git@github.com:rmurphy/devflow.git", "rmurphy", "devflow", false},
		{"git@gitlab.com:namespace/project.git", "namespace", "project", false},
		// Invalid URLs
		{"invalid", "", "", true},
		{"https://github.com/onlyrepo", "", "", true},
	}

	for _, tt := range tests {
		t.Run(tt.url, func(t *testing.T) {
			owner, repo, err := ParseRepoFromURL(tt.url)
			if tt.wantErr {
				if err == nil {
					t.Errorf("ParseRepoFromURL(%q) should return error", tt.url)
				}
				return
			}
			if err != nil {
				t.Errorf("ParseRepoFromURL(%q) error = %v", tt.url, err)
				return
			}
			if owner != tt.wantOwner {
				t.Errorf("owner = %q, want %q", owner, tt.wantOwner)
			}
			if repo != tt.wantRepo {
				t.Errorf("repo = %q, want %q", repo, tt.wantRepo)
			}
		})
	}
}

func TestPRState(t *testing.T) {
	states := []PRState{PRStateOpen, PRStateClosed, PRStateMerged}
	expected := []string{"open", "closed", "merged"}

	for i, state := range states {
		if string(state) != expected[i] {
			t.Errorf("PRState %d = %q, want %q", i, state, expected[i])
		}
	}
}

func TestMergeMethod(t *testing.T) {
	methods := []MergeMethod{MergeMethodMerge, MergeMethodSquash, MergeMethodRebase}
	expected := []string{"merge", "squash", "rebase"}

	for i, method := range methods {
		if string(method) != expected[i] {
			t.Errorf("MergeMethod %d = %q, want %q", i, method, expected[i])
		}
	}
}
