# ADR-005: PR Creation Patterns

## Status

Accepted

## Context

devflow automates pull request creation as the final step in many workflows. We need to decide:

1. How to format PR titles and descriptions
2. How to handle GitHub vs GitLab differences
3. What metadata to include
4. How to handle PR update scenarios

## Decision

### PR Options Structure

```go
type PROptions struct {
    Title       string            // PR title
    Body        string            // PR description (markdown)
    Base        string            // Target branch (default: "main")
    Head        string            // Source branch (auto-detected if empty)
    Labels      []string          // Labels to apply
    Reviewers   []string          // Reviewer usernames
    Assignees   []string          // Assignee usernames
    Draft       bool              // Create as draft
    Milestone   string            // Milestone name or ID
    Metadata    map[string]string // Additional metadata
}
```

### Title Format

PR titles follow a consistent format:

```
[{ticket}] {summary}
```

Examples:
- `[TK-421] Add user authentication`
- `[TK-422] Fix API null response handling`
- `[devflow] Automated refactoring`

For auto-generated PRs without tickets:
```
[devflow/{workflow}] {summary}
```

### Body Template

```markdown
## Summary

{brief description of changes}

## Changes

{bullet list of key changes}

## Test Plan

{how to verify the changes}

## Ticket

{link to ticket if applicable}

---
*Generated by devflow*
```

### Provider Abstraction

Single interface for GitHub and GitLab:

```go
type PRProvider interface {
    CreatePR(ctx context.Context, opts PROptions) (*PullRequest, error)
    UpdatePR(ctx context.Context, id int, opts PRUpdateOptions) (*PullRequest, error)
    GetPR(ctx context.Context, id int) (*PullRequest, error)
    MergePR(ctx context.Context, id int, opts MergeOptions) error
    AddComment(ctx context.Context, id int, body string) error
    RequestReview(ctx context.Context, id int, reviewers []string) error
}
```

### Provider Detection

Auto-detect provider from remote URL:

```go
func DetectProvider(remoteURL string) (PRProvider, error) {
    if strings.Contains(remoteURL, "github.com") {
        return NewGitHubProvider(remoteURL)
    }
    if strings.Contains(remoteURL, "gitlab.com") || strings.Contains(remoteURL, "gitlab") {
        return NewGitLabProvider(remoteURL)
    }
    return nil, ErrUnknownProvider
}
```

### Result Structure

```go
type PullRequest struct {
    ID          int       // PR number
    URL         string    // Web URL
    HTMLURL     string    // Full HTML URL
    Title       string    // PR title
    State       PRState   // open, closed, merged
    Draft       bool      // Whether it's a draft
    Head        string    // Source branch
    Base        string    // Target branch
    CreatedAt   time.Time
    UpdatedAt   time.Time
    MergedAt    *time.Time
    MergedBy    string
    Commits     int       // Number of commits
    Additions   int       // Lines added
    Deletions   int       // Lines deleted
    Labels      []string
    Reviewers   []string
}
```

### Error Handling

```go
var (
    ErrPRExists        = errors.New("pull request already exists for this branch")
    ErrBranchNotPushed = errors.New("branch not pushed to remote")
    ErrNoChanges       = errors.New("no changes between branches")
    ErrUnknownProvider = errors.New("unknown git provider")
    ErrPRNotFound      = errors.New("pull request not found")
    ErrPRClosed        = errors.New("pull request is closed")
    ErrPRMerged        = errors.New("pull request is already merged")
)
```

## Alternatives Considered

### Alternative 1: Provider-Specific Options

Have separate `GitHubPROptions` and `GitLabMROptions`.

**Rejected because:**
- Duplicates common fields
- Complicates node implementations
- Users need to handle both cases

### Alternative 2: CLI Tools Only

Use `gh` and `glab` CLI tools instead of APIs.

**Rejected because:**
- Additional dependencies
- Less control over output
- Harder to test

### Alternative 3: Markdown Body as Template File

Load PR body from template files on disk.

**Considered but deferred:**
- Good idea for future
- For now, programmatic templates sufficient
- Can add template loading as option later

## Consequences

### Positive

- **Unified interface**: Same code for GitHub and GitLab
- **Rich metadata**: PRs include all relevant context
- **Identifiable**: Clear markers for devflow-generated PRs
- **Updatable**: Can update existing PRs

### Negative

- **Least common denominator**: Some provider features unavailable
- **API rate limits**: API calls subject to rate limiting
- **Token management**: Need provider tokens configured

### GitHub-Specific Features

These GitHub features are supported through the abstraction:
- Labels
- Reviewers
- Assignees
- Draft PRs
- Milestones

### GitLab-Specific Features

These GitLab features are supported:
- Labels
- Assignees
- Reviewers
- Draft MRs
- Milestones

### Unsupported Features

These features are not abstracted (use provider directly):
- GitHub: Projects, check runs
- GitLab: Approvals, merge trains

## Code Example

```go
package devflow

import (
    "context"
    "fmt"
    "strings"
)

// PRState represents the state of a pull request
type PRState string

const (
    PRStateOpen   PRState = "open"
    PRStateClosed PRState = "closed"
    PRStateMerged PRState = "merged"
)

// PROptions configures pull request creation
type PROptions struct {
    Title     string
    Body      string
    Base      string
    Head      string
    Labels    []string
    Reviewers []string
    Assignees []string
    Draft     bool
    Milestone string
}

// PullRequest represents a created PR
type PullRequest struct {
    ID        int
    URL       string
    HTMLURL   string
    Title     string
    State     PRState
    Draft     bool
    Head      string
    Base      string
    Commits   int
    Additions int
    Deletions int
}

// PRBuilder helps construct PR options
type PRBuilder struct {
    opts PROptions
}

// NewPRBuilder creates a new PR builder
func NewPRBuilder(title string) *PRBuilder {
    return &PRBuilder{
        opts: PROptions{
            Title: title,
            Base:  "main",
        },
    }
}

// WithTicket adds ticket reference to title
func (b *PRBuilder) WithTicket(ticketID string) *PRBuilder {
    b.opts.Title = fmt.Sprintf("[%s] %s", ticketID, b.opts.Title)
    return b
}

// WithBody sets the PR body
func (b *PRBuilder) WithBody(body string) *PRBuilder {
    b.opts.Body = body
    return b
}

// WithSummary creates a formatted body
func (b *PRBuilder) WithSummary(summary string, changes []string, testPlan string) *PRBuilder {
    var body strings.Builder
    body.WriteString("## Summary\n\n")
    body.WriteString(summary)
    body.WriteString("\n\n## Changes\n\n")
    for _, change := range changes {
        body.WriteString("- ")
        body.WriteString(change)
        body.WriteString("\n")
    }
    body.WriteString("\n## Test Plan\n\n")
    body.WriteString(testPlan)
    body.WriteString("\n\n---\n*Generated by devflow*")
    b.opts.Body = body.String()
    return b
}

// WithBase sets the target branch
func (b *PRBuilder) WithBase(base string) *PRBuilder {
    b.opts.Base = base
    return b
}

// WithLabels adds labels
func (b *PRBuilder) WithLabels(labels ...string) *PRBuilder {
    b.opts.Labels = append(b.opts.Labels, labels...)
    return b
}

// WithReviewers adds reviewers
func (b *PRBuilder) WithReviewers(reviewers ...string) *PRBuilder {
    b.opts.Reviewers = append(b.opts.Reviewers, reviewers...)
    return b
}

// AsDraft creates as draft PR
func (b *PRBuilder) AsDraft() *PRBuilder {
    b.opts.Draft = true
    return b
}

// Build returns the PR options
func (b *PRBuilder) Build() PROptions {
    return b.opts
}

// GitContext.CreatePR creates a pull request
func (g *GitContext) CreatePR(ctx context.Context, opts PROptions) (*PullRequest, error) {
    // Auto-detect head branch if not specified
    if opts.Head == "" {
        var err error
        opts.Head, err = g.CurrentBranch()
        if err != nil {
            return nil, fmt.Errorf("get current branch: %w", err)
        }
    }

    // Verify branch is pushed
    if !g.isBranchPushed(opts.Head) {
        return nil, ErrBranchNotPushed
    }

    // Delegate to provider
    if g.github != nil {
        return g.github.CreatePR(ctx, opts)
    }
    if g.gitlab != nil {
        return g.gitlab.CreatePR(ctx, opts)
    }

    return nil, ErrNoPRProvider
}

func (g *GitContext) isBranchPushed(branch string) bool {
    _, err := g.runGit("rev-parse", "--verify", "origin/"+branch)
    return err == nil
}
```

### Usage

```go
// Simple PR
pr, err := git.CreatePR(ctx, devflow.PROptions{
    Title: "[TK-421] Add user authentication",
    Body:  "Implements OAuth2 login flow",
    Base:  "main",
})

// Using builder
pr, err := git.CreatePR(ctx, devflow.NewPRBuilder("Add user authentication").
    WithTicket("TK-421").
    WithSummary(
        "Implements OAuth2 login flow with Google and GitHub providers",
        []string{
            "Add OAuth2 handler",
            "Add provider configuration",
            "Add session management",
        },
        "1. Click 'Login with Google'\n2. Verify redirect to Google\n3. Complete OAuth flow\n4. Verify session created",
    ).
    WithLabels("feature", "auth").
    WithReviewers("alice", "bob").
    AsDraft().
    Build(),
)

fmt.Printf("Created PR: %s\n", pr.URL)
```

### Integration with Workflow

```go
func CreatePRNode(ctx flowgraph.Context, state DevState) (DevState, error) {
    git := ctx.Value(gitContextKey).(*GitContext)

    pr, err := git.CreatePR(ctx, devflow.NewPRBuilder(state.Spec.Title).
        WithTicket(state.TicketID).
        WithSummary(
            state.Spec.Summary,
            state.Implementation.Changes,
            state.Spec.TestPlan,
        ).
        Build(),
    )
    if err != nil {
        return state, fmt.Errorf("create PR: %w", err)
    }

    state.PR = pr
    return state, nil
}
```

## References

- [GitHub Pull Request API](https://docs.github.com/en/rest/pulls/pulls)
- [GitLab Merge Request API](https://docs.gitlab.com/ee/api/merge_requests.html)
- ADR-003: Branch Naming (source branch conventions)
- ADR-004: Commit Formatting (commit message in PR)
